import 'package:gotravel/data/models/search_model.dart';
import 'package:gotravel/data/models/place_model.dart';
import 'package:gotravel/data/models/tour_package_model.dart';
import 'package:gotravel/data/models/hotel_model.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

class SearchService {
  final SupabaseClient _supabase = Supabase.instance.client;

  /// Record search history
  Future<SearchHistoryModel> recordSearch({
    String? userId,
    required String searchQuery,
    String? searchType,
    SearchFilter? searchFilters,
    int resultsCount = 0,
    String? clickedItemId,
    String? clickedItemType,
    String? ipAddress,
    String? userAgent,
  }) async {
    try {
      final searchHistory = SearchHistoryModel(
        id: '', // Will be generated by database
        userId: userId,
        searchQuery: searchQuery,
        searchType: searchType,
        searchFilters: searchFilters?.toMap(),
        resultsCount: resultsCount,
        clickedItemId: clickedItemId,
        clickedItemType: clickedItemType,
        ipAddress: ipAddress,
        userAgent: userAgent,
        createdAt: DateTime.now(),
      );

      final response = await _supabase
          .from('search_history')
          .insert(searchHistory.toMap())
          .select()
          .single();

      return SearchHistoryModel.fromMap(response);
    } catch (e) {
      throw Exception('Failed to record search: $e');
    }
  }

  /// Get user search history
  Future<List<SearchHistoryModel>> getUserSearchHistory(String userId, {int limit = 20}) async {
    try {
      final response = await _supabase
          .from('search_history')
          .select('*')
          .eq('user_id', userId)
          .order('created_at', ascending: false)
          .limit(limit);

      final List data = response;
      return data.map((search) => SearchHistoryModel.fromMap(search)).toList();
    } catch (e) {
      throw Exception('Failed to fetch search history: $e');
    }
  }

  /// Get popular search queries
  Future<List<String>> getPopularSearchQueries({int limit = 10}) async {
    try {
      final response = await _supabase.rpc('get_popular_search_queries', params: {
        'limit_param': limit,
      });

      final List data = response;
      return data.map((item) => item['search_query'] as String).toList();
    } catch (e) {
      // If the function doesn't exist, return empty list
      return [];
    }
  }

  /// Search across all content types
  Future<Map<String, List<dynamic>>> globalSearch(String query, {
    SearchFilter? filters,
    int limit = 20,
  }) async {
    try {
      final results = <String, List<dynamic>>{};

      // Search places
      final places = await searchPlaces(query, filters: filters, limit: limit);
      results['places'] = places;

      // Search packages
      final packages = await searchPackages(query, filters: filters, limit: limit);
      results['packages'] = packages;

      // Search hotels
      final hotels = await searchHotels(query, filters: filters, limit: limit);
      results['hotels'] = hotels;

      return results;
    } catch (e) {
      throw Exception('Failed to perform global search: $e');
    }
  }

  /// Search places
  Future<List<PlaceModel>> searchPlaces(String query, {
    SearchFilter? filters,
    int limit = 20,
  }) async {
    try {
      var queryBuilder = _supabase
          .from('places')
          .select('*')
          .eq('is_active', true);

      // Apply text search
      if (query.isNotEmpty) {
        queryBuilder = queryBuilder.textSearch('name,description,country,city', query);
      }

      // Apply filters
      if (filters != null) {
        if (filters.country != null) {
          queryBuilder = queryBuilder.eq('country', filters.country!);
        }
        if (filters.category != null) {
          queryBuilder = queryBuilder.eq('category', filters.category!);
        }
        if (filters.minRating != null) {
          queryBuilder = queryBuilder.gte('rating', filters.minRating!);
        }
      }

      // Apply sorting
      final sortBy = filters?.sortBy ?? 'rating';
      final ascending = filters?.sortOrder == 'asc';
      
      final response = await queryBuilder
          .order(sortBy, ascending: ascending)
          .limit(limit);

      final List data = response;
      return data.map((place) => PlaceModel.fromMap(place)).toList();
    } catch (e) {
      throw Exception('Failed to search places: $e');
    }
  }

  /// Search packages
  Future<List<TourPackage>> searchPackages(String query, {
    SearchFilter? filters,
    int limit = 20,
  }) async {
    try {
      var queryBuilder = _supabase
          .from('packages')
          .select('''
            *, 
            package_activities(*),
            package_dates(*)
          ''')
          .eq('is_active', true);

      // Apply text search
      if (query.isNotEmpty) {
        queryBuilder = queryBuilder.textSearch('name,description,destination,country', query);
      }

      // Apply filters
      if (filters != null) {
        if (filters.destination != null) {
          queryBuilder = queryBuilder.ilike('destination', '%${filters.destination}%');
        }
        if (filters.country != null) {
          queryBuilder = queryBuilder.eq('country', filters.country!);
        }
        if (filters.category != null) {
          queryBuilder = queryBuilder.eq('category', filters.category!);
        }
        if (filters.minPrice != null) {
          queryBuilder = queryBuilder.gte('price', filters.minPrice!);
        }
        if (filters.maxPrice != null) {
          queryBuilder = queryBuilder.lte('price', filters.maxPrice!);
        }
        if (filters.minRating != null) {
          queryBuilder = queryBuilder.gte('rating', filters.minRating!);
        }
        if (filters.minDuration != null) {
          queryBuilder = queryBuilder.gte('duration_days', filters.minDuration!);
        }
        if (filters.maxDuration != null) {
          queryBuilder = queryBuilder.lte('duration_days', filters.maxDuration!);
        }
        if (filters.participants != null) {
          queryBuilder = queryBuilder.gte('max_participants', filters.participants!);
        }
      }

      // Apply sorting
      final sortBy = filters?.sortBy ?? 'rating';
      final ascending = filters?.sortOrder == 'asc';
      
      final response = await queryBuilder
          .order(sortBy, ascending: ascending)
          .limit(limit);

      final List data = response;
      return data.map((package) => TourPackage.fromMap(package)).toList();
    } catch (e) {
      throw Exception('Failed to search packages: $e');
    }
  }

  /// Search hotels
  Future<List<Hotel>> searchHotels(String query, {
    SearchFilter? filters,
    int limit = 20,
  }) async {
    try {
      var queryBuilder = _supabase
          .from('hotels')
          .select('''
            *,
            rooms(*)
          ''');

      // Apply text search
      if (query.isNotEmpty) {
        queryBuilder = queryBuilder.textSearch('name,description,city,country', query);
      }

      // Apply filters
      if (filters != null) {
        if (filters.country != null) {
          queryBuilder = queryBuilder.eq('country', filters.country!);
        }
        if (filters.minRating != null) {
          queryBuilder = queryBuilder.gte('rating', filters.minRating!);
        }
      }

      // Apply sorting
      final sortBy = filters?.sortBy ?? 'rating';
      final ascending = filters?.sortOrder == 'asc';
      
      final response = await queryBuilder
          .order(sortBy, ascending: ascending)
          .limit(limit);

      final List data = response;
      return data.map((hotel) => Hotel.fromMap(hotel)).toList();
    } catch (e) {
      throw Exception('Failed to search hotels: $e');
    }
  }

  /// Get search suggestions
  Future<List<String>> getSearchSuggestions(String query, {int limit = 5}) async {
    try {
      final suggestions = <String>[];

      // Get place suggestions
      final placeResponse = await _supabase
          .from('places')
          .select('name')
          .eq('is_active', true)
          .ilike('name', '%$query%')
          .limit(limit);

      for (final item in placeResponse) {
        suggestions.add(item['name'] as String);
      }

      // Get package destination suggestions
      final packageResponse = await _supabase
          .from('packages')
          .select('destination')
          .eq('is_active', true)
          .ilike('destination', '%$query%')
          .limit(limit);

      for (final item in packageResponse) {
        final destination = item['destination'] as String;
        if (!suggestions.contains(destination)) {
          suggestions.add(destination);
        }
      }

      return suggestions.take(limit).toList();
    } catch (e) {
      throw Exception('Failed to get search suggestions: $e');
    }
  }

  /// Clear user search history
  Future<void> clearUserSearchHistory(String userId) async {
    try {
      await _supabase
          .from('search_history')
          .delete()
          .eq('user_id', userId);
    } catch (e) {
      throw Exception('Failed to clear search history: $e');
    }
  }

  /// Delete individual search history item
  Future<void> deleteSearchHistoryItem(String searchHistoryId) async {
    try {
      await _supabase
          .from('search_history')
          .delete()
          .eq('id', searchHistoryId);
    } catch (e) {
      throw Exception('Failed to delete search history item: $e');
    }
  }

  /// Get search analytics for admin
  Future<Map<String, dynamic>> getSearchAnalytics() async {
    try {
      final response = await _supabase.rpc('get_search_analytics');
      return Map<String, dynamic>.from(response);
    } catch (e) {
      // If the function doesn't exist, calculate manually
      try {
        final allSearches = await _supabase.from('search_history').select('search_query, search_type, results_count, created_at');
        final List data = allSearches;

        int totalSearches = data.length;
        double avgResultsCount = data.isNotEmpty
            ? data.fold(0, (sum, s) => sum + (s['results_count'] as int)) / totalSearches
            : 0.0;

        final searchTypes = <String, int>{};
        for (final search in data) {
          final type = search['search_type'] as String? ?? 'general';
          searchTypes[type] = (searchTypes[type] ?? 0) + 1;
        }

        return {
          'total_searches': totalSearches,
          'average_results_count': avgResultsCount.toStringAsFixed(2),
          'search_types': searchTypes,
        };
      } catch (e2) {
        throw Exception('Failed to get search analytics: $e2');
      }
    }
  }

  /// Update search click tracking
  Future<void> updateSearchClick(String searchHistoryId, String clickedItemId, String clickedItemType) async {
    try {
      await _supabase
          .from('search_history')
          .update({
        'clicked_item_id': clickedItemId,
        'clicked_item_type': clickedItemType,
      })
          .eq('id', searchHistoryId);
    } catch (e) {
      // Don't throw error for click tracking failure
      print('Failed to update search click: $e');
    }
  }
}